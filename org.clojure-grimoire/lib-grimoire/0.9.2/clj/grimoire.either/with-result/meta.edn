{:ns "grimoire.either", :name "with-result", :file "grimoire/either.clj", :type :macro, :src "(defmacro with-result\n  \"This macro is a helper designed to emulate the Haskell pattern matching which\n  Clojure lacks by default.\n\n  Usage:\n  (with-result [x (could-fail-form)]\n    (use-x x))\n\n  In the two-arity case, the value expression is evaluated and if a failure is\n  generated it is passed back up the stack implicitly as this is assumed to be\n  the common case. If the possibly failing expression succeeds, then the result\n  is extracted and let-bound to the binding form. The binding form may contain\n  destructuring. Exceptions occuring inside the left form will be caught and\n  bound into Failure values.\n\n  Usage:\n  (with-result [x (could-fail-form)]\n    (use-x x)         ; x is the Result\n    (failure-case x)) ; x is the Message\n\n  In the three-arity case, the expression value is evaluated, and unaltered\n  value of the possibly failing form is bound to the given symbol. If the result\n  value is a success structure, then the \\\"left\\\" form is evaluated, otherwise\n  the \\\"right\\\" form is evaluated. No implicit result or error destructuring is\n  provided in this case. Exceptions occuring inside either form will be caught\n  and bound into Failure values.\"\n\n  ([[binding form] left]\n   `(let [res# ~form]\n      (if (succeed? res#)\n        (let [~binding (result res#)]\n          (try ~left\n               (catch Exception e# (fail e#))))\n        res#)))\n\n  ([[binding form] left right]\n   {:pre [(symbol? binding)]}\n   `(let [x# ~form]\n      (try (if (succeed? x#)\n             (let [~binding (result x#)] ~left)\n             (let [~binding (message x#)] ~right))\n           (catch Exception e# (fail e#))))))", :column 1, :line 56, :macro true, :arglists ([[binding form] left] [[binding form] left right]), :doc "This macro is a helper designed to emulate the Haskell pattern matching which\n  Clojure lacks by default.\n\n  Usage:\n  (with-result [x (could-fail-form)]\n    (use-x x))\n\n  In the two-arity case, the value expression is evaluated and if a failure is\n  generated it is passed back up the stack implicitly as this is assumed to be\n  the common case. If the possibly failing expression succeeds, then the result\n  is extracted and let-bound to the binding form. The binding form may contain\n  destructuring. Exceptions occuring inside the left form will be caught and\n  bound into Failure values.\n\n  Usage:\n  (with-result [x (could-fail-form)]\n    (use-x x)         ; x is the Result\n    (failure-case x)) ; x is the Message\n\n  In the three-arity case, the expression value is evaluated, and unaltered\n  value of the possibly failing form is bound to the given symbol. If the result\n  value is a success structure, then the \"left\" form is evaluated, otherwise\n  the \"right\" form is evaluated. No implicit result or error destructuring is\n  provided in this case. Exceptions occuring inside either form will be caught\n  and bound into Failure values."}